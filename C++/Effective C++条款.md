# Effective C++条款

## Effecitve C++

---

> 条款3

- 如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。
mutable 声明的成员变量可能总是被修改，即使在const成员函数内。

> 条款13

- auto_ptr是个“类指针对象”，也就是所谓“智能指针”，其析构函数自动对其所指对象调用delete。
- auto_ptr有一个不寻常的性质：若通过copy构造函数或copy assignment操作符复制它们，它们就会变成null，而复制所得的指针将取得资源的唯一拥有权。

> 条款16

- 如果你调用new时使用[]，你必须在对应调用delete时也使用[]。如果你调用new时没有使用[]，那么也不该在对应调用delete时使用[]。

> 条款20

- 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题。但这并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。

> 条款35

- 接口继承和实现继承不同。在public继承之下，派生类总是继承基类的接口。
- 纯虚函数只具体指定接口继承。
- 非纯虚函数具体指定接口继承及缺省实现继承。
- 非虚函数具体指定接口继承及强制性实现继承。

## More Effective C++

---

> 条款12：了解“抛出一个exception”与“传递一个参数”或“调用一个虚函数”之间的差异

1. exception objects总是会被复制，如果以by value方式捕捉，它们甚至被复制两次。至于传递给函数参数的对象则不一定得复制。
2. “被抛出成为exception”的对象，其被允许的类型转换动作，比“被传递到函数去”的对象少。
3. catch子句以其“出现于源代码的顺序”被编译器校验比对，其中第一个匹配成功者便执行；而当我们以某对象调用一个虚函数，被选中执行的是那个“与对象类型最佳吻合”的函数，不论它是不是源代码所列的第一个。

> 条款26：限制某个class所能产生的对象数量

- “class拥有一个static对象”：即使从未使用到，它也会被构造及析构。
- “函数拥有一个static对象”：此对象在函数第一次被调用时才产生。如果该函数从未被调用，这个对象也就绝不会诞生（然而你必须付出代价，在函数每次被调用时检查对象是否需要诞生）。

> 条款24

- 虚函数不应该使用inline。因为“inline”意味`在编译期，将调用端的调用动作被调用函数的函数本体取代`，而“virtual”则意味着`等待，直到运行期才知道哪个函数被调用`。
