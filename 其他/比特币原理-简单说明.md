# 比特币原理-简单说明

## 1.基础

历史：

2008年 Satoshi Nakamoto(中本聪) 发表论文“Bitcoin：A Peer-to-Peer Electronic Cash System”

2009年1月3号 发出第一个区块

定义：

比特币是构成数字货币生态系统基础的概念和技术的集合

特点：

1. 完全虚拟 2. 分布式对等系统

创新：

1. 去中心化的对等网络（比特币协议）
2. 公共交易总帐（区块链）
3. 独立交易确认和货币发行的一套规则（共识规则）
4. 实现有效的区块链全球去中心化共识的机制（工作量证明算法）

开始：

1. 选择钱包（自动创建新钱包） https://bitcoin.org/zh_CN/choose-your-wallet 
2. (有图)买比特币 https://coinatmradar.com/ 

## 2.原理

交易

简单来说，交易告知全网：比特币的持有者已授权把比特币转帐给其他人。
每一笔交易包含一个或多个“输入”，输入是针对一个比特币账号的负债
这笔交易的另一面，有一个或多个“输出”，被当成信用积分记入到比特币账户中。
当输出累加略少于输入量时，两者的差额就代表了一笔隐含的“矿工费”
“消费”指的是签署一笔交易：转移一笔以前交易的比特币给以比特币地址所标识的新所有者。
(有图)交易链、找零
交易构建
	获取输入
	构建输出
	放进总账本
挖矿
	数独游戏比喻，很恰当
挖矿交易记录
	一个区块获得六次以上“确认”时就被认为是不可撤销的了，撤销和重建六个区块需要巨量的计算
(有图)消费交易

## 3.核心

(有图)核心架构（程序员了解）

## 4.密钥与地址

私钥-公钥-地址的关系
	(有图)公钥加密(与公钥没啥关系，类似哈希变换)生成密钥对--公钥/私钥，公钥通过单向加密哈希函数得到地址
私钥
	随机的一个数字(1-1.158 * 10^77 < 2^256)
	抛硬币256次
	从编程的角度来看，一般是通过在一个密码学安全的随机源中取出一长串随机字节，对其使用SHA256哈希算法进行运算，这样就可以方便地产生一个256位的数字
	1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
		用十进制表示的话，大约是10^77，而可见宇宙被估计只含有10^80个原子。
椭圆曲线乘法(不可逆转)
	K = k * G 。其中k是私钥，G是被称为生成点的常数点，而K是所得公钥
	其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是非常困难的，就像去试验所有可能的k值，即暴力搜索
	(有图)椭圆曲线加密法是一种基于离散对数问题的非对称加密法
	(有图)比特币使用了secp256k1标准所定义的一种特殊的椭圆曲线和一系列数学常数。该标准由美国国家标准与技术研究院 （NIST）设立。mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2^256 – 2^32 – 2^9 – 2^8 – 2^7 – 2^6 – 2^4 – 1
	还有一个 + 运算符，被称为“加法”，就像小学数学中的实数相加。给定椭圆曲线上的两个点P1和P2，则椭圆曲线上必定有第三点 P3 = P1 + P2。 几何图形中，该第三点P3可以在P1和P2之间画一条线来确定。这条直线恰好与椭圆曲线相交于另外一个地方。此点记为 P3'= (x，y)。然后，在x轴做翻折获得 P3=(x，-y)。
	若 P1和 P2是同一点，P1和P2间的连线则为点P1 的切线。曲线上有且只有一个新的点与该切线相交。该切线的斜率可用微积分求得。即使限制曲线点为两个整数坐标也可求得斜率！
在某些情况下（即，如果P1和P2具有相同的x值，但不同的y值），则切线会完全垂直，在这种情况下，P3 = “无穷远点”。
若P1就是“无穷远点”，那么其和 P1 + P2= P2。类似地，当P2是无穷远点，则P1+ P2 = P1。
公钥
	所有比特币用户的生成点是相同的
	(有图)K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
	K = (x, y) x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
比特币地址
	一个由数字和字母组成的字符串，可以与任何想给你比特币的人分享
	(有图)A = RIPEMD160(SHA256(K))
	Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母 L）、I（大写字母i），以及“+”和“/”两个字符
	base58check 有内置的检查错误的编码。检验和是添加到正在编码的数据末端的额外4个字节
	(有图)为了将数据（数字）转换成Base58Check格式，首先我们要对数据添加一个称作“版本字节”的前缀，这个前缀用来识别编码的数据的类 型。例如，比特币地址的前缀是0（十六进制是0x00），而对私钥编码时前缀是128（十六进制是0x80）。 表4-1会列出一些常见版本的前缀。
	(有图)总过程
密钥格式
	(有图)私钥  格式&&例子
	公钥
		公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥， 压缩格式公钥是以02或者03开头
		如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。
(有图)靓号地址

## 5.钱包

用于存储和管理用户密钥的数据结构
(有图)非确定性（随机）钱包
(有图)确定性（种子）钱包--从单个“种子”中生成许多密钥
(有图)分层确定性钱包（HD Wallets (BIP-32/BIP-44)）
(有图)创建助记词
1、创建一个128到256位的随机序列（熵）。
2、提出SHA256哈希前几位（熵长/ 32），就可以创造一个随机序列的校验和。
3、将校验和添加到随机序列的末尾。
4、将序列划分为包含11位的不同部分。
5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。
6、生成的有顺序的单词组就是助记码。
	从助记词生成种子
		助记词表示长度为128至256位的熵。 通过使用密钥延伸函数PBKDF2，熵被用于导出较长的（512位）种子
		(有图)创建助记词之后的7-9步是：
7、PBKDF2密钥延伸函数的第一个参数是从步骤6生成的助记符。
8、PBKDF2密钥延伸函数的第二个参数是盐。 由字符串常数“助记词”与可选的用户提供的密码字符串连接组成。
9、PBKDF2使用HMAC-SHA512算法，使用2048次哈希来延伸助记符和盐参数，产生一个512位的值作为其最终输出。 这个512位的值就是种子。
助记码在线生成 https://iancoleman.io/bip39/
	从种子生成钱包
(有图)整个过程
(有图)母公共钥匙——链码——以及索引号合并在一起并且用HMAC-SHA512函数散列之后可以产生512位的散列。所得的散列可被拆分为两部分。散列右半部分的256位产出可以给子链当链码。左半部分256位散列以及索引码被加载在母私钥上来衍生子私钥。
扩展密钥
		密钥以及链码这两个重要的部分被结合之后，就叫做扩展密钥（extended key） 有两种扩展密钥。扩展私钥是私钥以及链码的结合。它可被用来衍生子私钥（子私钥可以衍生子公钥）。公钥以及链码组成扩展公钥，它可以用来扩展子公钥
		(有图)硬化子密钥的衍生
		索引号在0和2^31–1(0x0 to 0x7FFFFFFF)之间的是只被用在常规衍生。索引号在2^31和2^32– 1(0x80000000 to 0xFFFFFFFF)之间的只被用在强化衍生。因此，索引号小于2^31就意味着子密钥是常规的，而大于或者等于2^31的子密钥就是强化型的
		HD钱包中的密钥是用“路径”命名的，且每个级别之间用斜杠（/）字符来表示（见表5-6）。由主私钥衍生出的私钥起始以“m”打头。由主公钥衍生的公钥起始以“M“打头。因此，母密钥生成的第一个子私钥是m/0。第一个公钥是M/0。第一个子密钥的子密钥就是m/0/1，以此类推。密钥的“祖先”是从右向左读，直到你达到了衍生出的它的主密钥。举个例子，标识符m/x/y/z描述的是子密钥m/x/y的第z个子密钥。而子密钥m/x/y又是m/x的第y个子密钥。m/x又是m的第x个子密钥。

## 6.交易

(有图)原始交易数据
交易的输入输出
	交易输出包含两部分：一定量的比特币，面值为“聪”（satoshis），是最小的比特币单位；确定花费输出所需条件的加密难题（cryptographic puzzle）；这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。
	(有图)输出序列化
	列表中只有一个输入（因为一个UTXO包含足够的值来完成此付款）。 输入包含四个元素：
一个交易ID，引用包含正在使用的UTXO的交易；一个输出索引（vout），用于标识来自该交易的哪个UTXO被引用（第一个为零）；一个 scriptSig（解锁脚本），满足放置在UTXO上的条件，解锁它用于支出；一个序列号（至少需要有一个序列号比0xFFFFFFFF低的输入来激活锁定时间）
	不仅仅是Alice的钱包需要检索输入中引用的UTXO。一旦将该交易广播到网络，每个验证节点也将需要检索交易输入中引用的UTXO，以验证该交易。
	(有图)输入序列化
	交易费是基于交易的千字节规模来计算的，而不是比特币交易的价值。 尽力而为的原则
自从至少2016年初以来，比特币网络容量的限制已经造成交易之间的竞争，从而导致更高的费用，
免费交易彻底成为过去式。零费用或非常低费用的交易鲜少被处理，有时甚至不会在网络上传播。
目前默认的minrelaytxfee是每千字节0.00001比特币或者millibitcoin的1%；默认：费用低于0.0001比特币的交易是免费的
	**如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理。
交易脚本
	比特币交易脚本语言，称为脚本，是一种类似Forth的逆波兰表达式的基于堆栈的执行语言。除了有条件的流控制以外，没有循环或复杂流控制能力,这意味着脚本有限的复杂性和可预见的执行次数
	锁定脚本是一个放置在输出上面的花费条件：它指定了今后花费这笔输出必须要满足的条件。 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为脚本公钥（scriptPubKey）
解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，它将允许输出被消费。解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。
	(有图)每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本。 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效
	(有图)比特币的脚本语言被称为基于堆栈的语言，因为它使用一种被称为堆栈的数据结构。2 3 OP_ADD 5 OP_EQUAL
	(有2图)P2PKH（Pay-to-Public-Key-Hash）<Cafe Signature> <Cafe Public Key> OP_DUP OP_HASH160 <Cafe Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
数字签名
	比特币中使用的数字签名算法是椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm）或ECDSA；第一，签名证明私钥的所有者 第二，授权证明是不可否认的（不可否认性） 第三，签名证明交易（或交易的具体部分）在签字之后没有也不能被任何人修改。
	((Sig = F{sig}(F{hash}(m), dA)))  
dA 是签名私钥  
m 是交易（或其部分）
F~hash~ 是散列函数
F~sig~ 是签名算法  
Sig 是结果签名
	(看代码分析)Sig = (R, S)   签名序列化（DER）
0x30 - 表示DER序列的开始(签名有经过DER编码)
0x45 - 序列的长度（69字节）
0x02 - 一个整数值
0x21 - 整数的长度（33字节）
R - 00884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb
0x02 - 接下来是一个整数
0x20 - 整数的长度（32字节）
S - 4b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813
后缀（0x01）指示使用的哈希的类型（SIGHASH_ALL）
(有图)哈希类型
(有图)签名公式
k是临时私钥(随机数)
R是临时公钥的x坐标
dA是签名私钥
m是交易数据
p是椭圆曲线的主要顺序
(有图)验证公式	
R和S是签名值
Qa是Alice的公钥
m是签署的交易数据
G是椭圆曲线发生器点
如果计算点P的x坐标等于R，则验证者可以得出结论，签名是有效的。

## 7.网络

比特币采用了基于国际互联网（Internet）的P2P（peer-to-peer）网络架构。P2P是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点。
P2P网络也因此具有可靠性、去中心化，以 及开放性。“扩展比特币网络（extended bitcoin network）”指代所有包含比特币P2P协议、矿池挖矿协议、Stratum 协议以及其他连接比特币系统组件相关协议的整体网络结构。
(有图)常见节点类型
一些节点保有一份完整的、最新的区块链拷贝，这样的节点被称为“全节点”。全节点能够独立自主地校验所有交易，而不需借由任何外部参照。每个节点都参与全网络的路由功能，同时也可能包含其他功能。每个节点都参与验证并传播交易及区块信息，发现并维持与对等节点的连接。
	还有一些节点只保留了区块链的一部分，它们通过一种名为“简易支付验证（SPV）”的方 式来完成交易验证。这样的节点被称为“SPV节点”，又叫“轻量级节点”。
	挖矿节点通过运行在特殊硬件设备上的工作量证明（proof-of-work）算法，以相互竞争的方式创建新的区块。一些挖矿节点同时也是全节点，保有区块链的完整拷贝；还有一些参与矿池挖矿的节点是轻量级节点，它们必须依赖矿池服务器维护的全节点进行工作。
	用户钱包也可以作为全节点的一部分，这在桌面比特币客户端中比较常见。当前，越来越多的用户钱包都是SPV节点， 尤其是运行于诸如智能手机等资源受限设备上的比特币钱包应用；而这正变得越来越普遍
(有图)扩展网络
网络发现
	(有图)节点通常采用TCP协议、使用8333端口与已知的对等节点建立连接。在建立连接时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通信过 程
▷ nVersion 定义了客户端所“说出”的比特币P2P协议所采用的版本（例如：70002）。
▷ nLocalServices 一组该节点支持的本地服务列表，当前仅支持NODE_NETWORK
▷ nTime 当前时间
▷ addrYou 当前节点可见的远程节点的IP地址
▷ addrMe 本地节点所发现的本机IP地址
▷ subver 指示当前节点运行的软件类型的子版本号（例如：”/Satoshi:0.9.2.1/”）
▷ BaseHeight 当前节点区块链的区块高度 
第一种方法是使用多个“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表。
一些DNS种子提供了稳定的比特币侦听节点的静态IP地址列表
一些DNS种子是BIND（Berkeley Internet Name Daemon）的自定义实现，它从搜索器或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集。 
Bitcoin Core客户端包含五种不同DNS种子的名称
	不知道网络的引导节点必须被给予至少一个比特币节点的IP地址，之后可以通过进一步介绍来建立连接。 命令行参数-seednode可用于连接到一个节点，仅用于将其用作种子。
	(有图)由于节点可以随时加入和离开，通讯路径是不可靠的。因此，节点必须持续进行两项工作：在失去已有连接时发现新节点，并在其他节点启动时为其提供帮助。
(有图)交换“库存清单”
	第一批可供分享的500个区块，通过使用inv（inventory）消息把这些区块的哈希值传播出去
	会追踪记录其每个对等节点连接上“正在传输”（指那些它已经发出了请求但还没有接收到）的区块数量，并且检查该数量有没有超过上限（ MAX_BLOCKS_IN_TRANSIT_PER_PEER ）
简易支付验证 （Simplified Payment Verification (SPV) ）节点
	SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000
	一个全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性。SPV节点则不能验证UTXO是否还未被支付,验证交易的有效性，双重支付的问题。一个交易实际上不存在，SPV节点不会误认为该交易存在于某区块中。SPV节点会通过请求merkle路径证明以及验证区块链中的工作量证明，来证实交易的存在性。
	(有图)发出响应的对等节点将用一条headers 消息发送多达2000个区块头
	由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险
Bloom过滤器，用以解决SPV节点的隐私风险问题
	(有图)可变长度（N）的二进制数组（N位二进制数构成一个位域）和数量可变（M）的一组哈希函数组成
	(有图)简易Bloom过滤器添加关键词“A”
	(有图)简易Bloom过滤器里增加第二个关键词“B”
	(有图)验证关键词“X”是否在前述Bloom过滤器中
	(有图)验证关键词“Y”是否存在于简易Bloom过滤器中
	SPV节点将列出所有感兴趣的地址，密钥和散列，它将通过从其钱包控制的任何UTXO中提取公钥哈希和脚本哈希和交易ID来实现
	完整节点根据bloom过滤器检查交易的几个部分，寻找匹配，包括：
交易ID
每个交易输出的锁定脚本的数据组件（脚本中的每个键和哈希）
每个交易输入
每个输入签名数据组件（或见证脚本）
交易池
	比特币网络中几乎每个节点都会维护一份未确认交易的临时列表，被称为内存池或交易池。
节点们利用这个池来追踪记录那些被网络所知晓、但还未被区块链所包含的交易。
	有些节点的实现还维护一个单独的孤立交易池。如果一个交易的输入与某未知的交易有关，如与缺失的父交易相关，该孤立交易就会被暂时储存在孤立交易池中直到父交易的信息到达。
	有些比特币客户端的实现还维护一个UTXO数据库，也称UTXO池，是区块链中所有未支付交易输出的集合。UTXO池不同于交易池和孤立交易池的地方在于，它在初始化时不为空，而是包含了数以百万计的未支付交易输出条目，有些条目的历史甚至可以追溯至2009年。UTXO池可能会被安置在本地内存，或者作为一个包含索引的数据库表安置在永久性存储设备中。

## 8.区块链

区块链的数据结构是由包含交易信息的区块按照从远及近的顺序有序链接起来的。比特币核心客户端使用Google的LevelDB数据库存储区块链元数据。区块被从远及近有序地链接在这个链条里，每个区块都指向前一个区块。一个区块出现多个子区块的情况被称为“区块链分叉”。区块链分叉只是暂时状态，只有当多个不同区块几乎同时被不同的矿工发现时才会发生。
(有图)区块结构
区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头大1000倍。
(有图)区块头
区块标识符：区块头哈希值和区块高度。一个通过SHA256算法对区块头进行二次哈希计算而得到的数字指纹；区块哈希值是当该区块从网络被接收时由每个节点计算出来的。区块的哈希值可能会作为区块元数据的一部分被存储在一个独立的数据库表中，以便于索引和更快地从磁盘检索区块。
(有代码)创世区块：区块链里的第一个区块创建于2009年，被称为创世区块。它是区块链里面所有区块的共同祖先，这意味着你从任一区块，循链向后回溯，最终都将到达创世区块。
区块链接成为区块链。比特币的全节点在本地保存了区块链从创世区块起的完整副本。随着新的区块的产生，该区块链的本地副本会不断地更新用于扩展这个链条。
(有图)Merkle 树
Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。在比特币的Merkle树中两次使用到了SHA256 算法，因此其加密哈希算法也被称为double-SHA256。公式：HA = SHA256(SHA256(Transaction A))
	(有图)因为Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。
	(有图)在比特币中，在单个区块中有成百上千的交易是非常普遍的，这些交易都会采用同样的方法归纳起来，产生一个仅仅32字节的数据作为Merkle根。
	(有图)为了证明区块中存在某个特定的交易，一个节点只需要计算log2
(N)个32字节的哈希值，形成一条从特定交易到树根的认证路径或者Merkle路径即可
	(有图)Merkle树的高效随着交易规模的增加而变得异常明显。从表中可以看出，当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，为证明交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。
9.挖矿和共识
挖矿最重要的作用是巩固了去中心化的清算交易机制，通过这种机制，交易得到验证和清算。 挖矿是使得比特币与众不同的发明，它实现去中心化的安全机制，是P2P数字货币的基础。新币发行和交易费的奖励是将矿工的行动与网络安全保持一致的激励计划，同时实现了货币发行
(有图)每开采210,000个块，大约耗时4年，货币发行速率降低50%。2012年11月，比特币的新发行速度降低到每区块25个比特币；2016年7月，降低到12.5比特币/区块。在经过693万个区块之后，所有的共 2,099,999,997,690,000聪比特币将全部发行完毕。在那之后，新的区块不再包含比特币奖励，矿工的收益全部来自交易费
去中心化共识
中本聪的主要发明就是这种去中心化的自发共识（emergent consensus）机制。共识是数以千计的独立节点遵守了简单的规则通过异步交互自发形成的产物
▷ 每个全节点依据综合标准对每个交易进行独立验证
▷ 通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块
▷ 每个节点独立的对新区块进行校验并组装进区块链
▷ 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链。
(代码)交易的独立性校验
挖矿节点
在比特币网络中进行接收和传播未确认交易记录
把这些交易记录打包进入一个新区块
时刻监听着传播到比特币网络的新区块
矿工间的竞争以新区块的传播而结束，如同宣布谁是最后的赢家
一轮竞争的结束也代表着下一轮竞争的开始
打包交易至区块
	(有代码)创币交易。区块中的第一笔交易是笔特殊交易，称为创币交易或者coinbase交易。
	奖励与矿工费。为了构造创币交易，挖矿节点需要计算矿工费的总额。Total Fees = Sum(Inputs) - Sum(Outputs)。将coinbase奖励额（变量 nSubsidy ）与矿工费(nFee)总额求和
	(有图)在Coinbase交易中，“交易哈希”字段32个字节全部填充0，“交易输出索引”字段全部填充0xFF(十进制的255)，这两个字段的值表示不引用UTXO。“解锁脚本”由coinbase数据代替，数据可以由矿工自定义。除了开始的几个字节外，矿工可以任意使用coinbase的其他部分，随意填充任何数据。以创世块为例，中本聪在coinbase中填入了这样的数据“The Times 03/Jan/ 2009 Chancellor on brink of second bailout for banks“(泰晤士报 2009年1月3日 财政大臣将再次对银行施以援手)，表示对日期的证明，同时也表达了对银行系统的不信任。
(看上面的代码)第一个字节是03，脚本执行引擎执行这个指令将后面3个字节压入脚本栈,紧接着的3个字节——0x443b04， 是以小端格式(最低有效字节在先)编码的区块高度。翻转字节序得到0x043b44，表示为十进制是277,316。紧接着的几个十六进制数（03858402062）用于编码extra nonce(参见"10.11.1 随机值升位方案")，或者一个随机值，从而求解一个适当的工作量证明。
(有图)构造区块头
	时间戳，以Unix纪元时间编码，即自1970年1月1日0点到当下总共流逝的秒数
	难度在区块中以“尾数-指数”的格式，编码并存储，这种格式称作target bits（难度位）。这种编码的首字节表示指数，后面的3字节表示尾数(系 数)。
	最后一个字段是nonce，初始值为0。区块头完成全部的字段填充后，挖矿就可以开始进行了。挖矿的目标是找到一个使区块头哈希值小于难度目标的 nonce。
	向区块头填充merkle根字段，要将全部的交易组成一个merkle树。创币交易作为区块中的首个交易。
构建区块
	挖矿就是重复计算区块头的哈希值，不断修改该参数，直到与哈希值匹配的一个过程。
哈希函数 的结果无法提前得知，也没有能得到一个特定哈希值的模式。哈希函数的这个特性意味着：得到哈希值的唯一方法是不断的尝试，每次随机修改输入，直到出现适当的哈希值。
哈希函数输入一个任意长度的数据，输出一个长度固定且绝不雷同的值，可将其视为输入的数字指纹。
	(有代码)类似这样在语句末尾的变化的数字叫做nonce（随机数）。找到一个语句，使之哈希值的十六进制表示以 0开头。概率1/16，数学小于0x100...，目标阈值，目的是找到一个小于这个目标的哈希值。从实现目标难度取得成功所需的工作量。当算法是基于诸如SHA256的确定性函数时，输入本身就成为证据，必须要一定的工作量才能产生低于目标的结果。 因此，称之为工作量证明。尽管每次尝试产生一个随机的结果，但是任何可能的结果的概率可以预先计算。
	成功的nonce为13，且这个结果能被所有人独立确认。任何人将13加到语句 "I am Satoshi Nakamoto" 后面再计算哈希值都能确认它比目标值要小。这个正确的结果同时也是工作量证明。验证这个哈希值只需要一次计算，而我们找到它却花了13次。如果目标值更小（难度更大），那我们需要多得多的哈希计算才能找到合适的nonce，但其他人验证它时只需要一次哈希计算。知道目标值后，任何人都可以用统计学来估算其难度，因此就能知道找到这个nonce需要多少工作。目标和难度是成反比。
	前两位十六进制数字为幂（exponent），接下来得六位为系数（coefficient）。计算难度目标的公式为：target = coefficient * 2^(8 * (exponent – 3))
	​为了防止难度的变化过快，每个周期的调整幅度必须小于一个因子（值为4）。如果要调整的幅度大于4倍，则按4倍调整。由于在下一个2,016区块的周期不平衡的情况会继续存在，所以进一步的难度调整会在下一周期进行。因此平衡哈希计算能力和难度的巨大差异有可能需要花费几个2,016区块周期才会完成。
挖呀挖，经过亿万次hash运算后找到目标值，发到网络的其他结点。
​比特币共识机制的第三步是通过网络中的每个节点独立校验每个新区块。
每一个节点在将它转发到其节点之前，会进行一系列的测试去验证它。
▷ 区块的数据结构语法上有效
▷ 区块头的哈希值小于目标难度（确认包含足够的工作量证明）
▷ 区块时间戳早于验证时刻未来两个小时（允许时间错误）
▷ 区块大小在长度限制之内
▷ 第一个交易（且只有第一个）是coinbase交易
▷ 使用检查清单验证区块内的交易并确保它们的有效性
区块链的组装与选择
	节点维护三种区块：第一种是连接到主链上的，第二种是从主链上产生分支的（备用链），最后一种是在已知链中没有找到已知父区块的。​如果节点收到了一个有效的区块，而在现有的区块链中却未找到它的父区块，那么这个区块被认为是“孤块”。孤块会被 保存在孤块池中，直到它们的父区块被节点收到。一旦收到了父区块并且将其连接到现有区块链上，节点就会将孤块从 孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。当两个区块在很短的时间间隔内被挖出来，节点有 可能会以相反的顺序接收到它们，这个时候孤块现象就会出现。
	区块链分叉
		(有图)网络有一个统一的区块链视角
		(有图)两名矿工在较短的时间 内，各自都算得了工作量证明解
		(有图)两个区块开始在网络传播时，一些节点首先接收到三角形区块，另外一些节点首先接收倒三角形区块
		(有图)假如工作在“三角形”区块上的矿工找到了一个“菱形”区块 延长了区块链(星形-三角形-菱形)，他们会立刻传播这个新区块，整个网络会都会认为这个区块是有效的
		(有图)更多累积的工作。将星形-三角形-菱形设置为主链，并将星型-倒三角形链变为备用链
		单区块分叉每周都会发生，而双块分叉则非常罕见。比特币将区块间隔设计为10分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。
挖矿和算力竞赛
	(看代码)比如在2010年和2011年，很多矿工开始从使用CPU升级到使用GPU，进而使用FGPA（现场可编程门阵列）挖矿；在2013年，ASIC挖矿的引入，把SHA256算法直接固化在挖矿专用的硅芯片上，引起了算力的另一次巨大飞跃。一台采用这种芯片的矿机可以提供的算力，比2010年比特币网络的整体算力还要大。现在的竞争已经不再是比较单一芯片的能力，而是一个矿场能塞进多少芯片，并处理好散热和供电问题。
	随机值升位方案 the extra nonce solution
		在比特币的早期，矿工可以通过遍历随机数(Nonce)获得符合要求的hash来挖出一个块。
难度增长后，矿工经常在尝试了40亿个值后仍然没有出块。然而，这很容 易通过读取块的时间戳并计算经过的时间来解决。当挖矿硬件的速度达到了4GH/秒，这种方法变得越来越困难，因为随机数的取值在一秒内就被用尽了。当出现ASIC矿机并很快达到了TH/秒的hash速率后，挖矿软件为了找到有效的块，需要更多的空间来储存nonce值。解决方案是使用coinbase交易作为额外的随机值来源，因为coinbase脚本可以储存2-100字节的数据，矿工们开始使用这个空间作为额外随机值的来源。8个字节的额外随机数，加上4个字节的“标准”随机数，允许矿工每秒尝试2^96（8后面跟28个零）种可能性而无需修改时间戳。如果未来矿工穿过了以上所有的可能性，他们还可以通过修改时间戳来解决。
	矿池
		个体矿工独立工作（也就是solo挖矿）没有一点机会，矿工们合作组成矿池，汇集数以千计参与者们的算力并分享奖励。矿池通过专用挖矿协议协调成百上千的矿工。个人矿工在建立矿池账号后，设置他们的矿机连接到矿池服务器。矿池中的矿工分享挖矿任务，之后分享奖励。成功出块的奖励支付到矿池的比特币地址，而不是单个矿工的。一旦奖励达到一个特定的阈值，矿池服务器便会定期支付奖励到矿工的比特币地址。矿池对任何矿工开放，无论大小、专业或业余，设置一个较低难度的前提下，使用比特币的工作量证明算法来衡量每个矿工的 贡献。一个矿池会将矿池难度设置在保证一个单独的矿工能够频繁地找到一个符合矿池难度的区块头hash来赢取份 额。时不时的，某次尝试会产生一个符合比特币网络目标的区块头hash，产生一个有效块，然后整个矿池获胜。（扔骰子的游戏）
		大部分矿池是“托管的”，意思是有一个公司或者个人经营一个矿池服务器。矿池服务器的所有者叫矿池管理员，同时他 从矿工的收入中收取一个百分比的费用。矿工连接到矿池服务器使用一个采矿协议比如Stratum(STM)或者 GetBlockTemplate(GBT)。
		托管矿池存在管理人作弊的可能，管理人可以利用矿池进行双重支付或使区块无效。P2Pool是一个点对点的矿池，没有中心管理 人。P2Pool通过将矿池服务器的功能去中心化，实现一个并行的类似区块链的系统，名叫份额链（share chain）。一个份额链是一个难度低 于比特币区块链的区块链系统。份额链允许池中矿工在一个去中心化的池中合作，以每30秒一个份额区块的速度在份额 链上采矿，并获得份额。份额链上的区块记录了贡献工作的矿工的份额，并且继承了之前份额区块上的份额记录。当一 个份额区块上还实现了比特币网络的难度目标时，它将被广播并包含到比特币的区块链上，并奖励所有已经在份额链区 块中取得份额的池中矿工。
共识攻击
	比特币的共识机制指的是，被矿工（或矿池）试图使用自己的算力实行欺骗或破坏的难度很大。
共识攻击只能影响整个区块链未来的共识，或者说，最多能影响不久的过去几个区块的共识（最多影响过去10个块）。而且随着时间的推移，整个比特币块链被篡改的可能性越来越低。
共识攻击也不会影响用户的私钥以及加密算法（ECDSA）。
共识攻击也不能从其他的钱包那里偷到比特币、不签名地支付比特币、重新分配比特币、改变过去的交易或者改变比特币持有纪 录。
共识攻击能够造成的唯一影响是影响最近的区块（最多10个）并且通过拒绝服务来影响未来区块的生成。故意制造块链分叉来实现“双重支付”或者通过拒绝服务的方式来阻止特定的交易或者攻击特定的钱包地址。“51%攻击”例子
双重支付只能在攻击者拥有的钱包所发生的交易上进行，因为只有钱包的拥有者才能生成一个合法的签名用 于双重支付交易。
攻击者在自己的交易上进行双重支付攻击，如果可以通过使交易无效而实现对于不可逆转的购买行为不予付款， 这种攻击就是有利可图的。
一些安全研究组织利用统计模型得出的结论是，算力达到全网的30%就足以发动51%攻击了。

改变共识规则(软分叉/硬分叉)，课外了解
